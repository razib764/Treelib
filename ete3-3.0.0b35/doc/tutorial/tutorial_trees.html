

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Working With Tree Data Structures &mdash; ETE Toolkit - analysis and visualization of trees</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="About these documents"
              href="../about.html"/>
    <link rel="top" title="ETE Toolkit - analysis and visualization of trees" href="../index.html"/>
        <link rel="up" title="The ETE tutorial" href="index.html"/>
        <link rel="next" title="The Programmable Tree Drawing Engine" href="tutorial_drawing.html"/>
        <link rel="prev" title="The ETE tutorial" href="index.html"/>
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
           (i[r].q=i[r].q||[]).push(arguments)
    },i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

 ga('create', 'UA-783841-4', 'etetoolkit.org');
 ga('send', 'pageview');
 </script>

<!-- 
 <script type="text/javascript">
 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-783841-12']);
 _gaq.push(['_setCookiePath', '/ete2/']);
 _gaq.push(['_trackPageview']);

 (function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 })();
 </script>
 -->
<!-- <link rel="canonical" href="http://etetoolkit.org/docs/2.3/CANONICALPATH" />
<meta http-equiv="refresh" content="0; url=http:/etetoolkit.org/CANONICALPATH" />
<script type="text/javascript">
window.location.replace('http://etetoolkit.org/docs/2.3/' + window.location.pathname.replace('/ete2/',''));
</script> -->
 
 


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ETE Toolkit
          

          
          </a>

          
            
            
              <div class="version">
                3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Changelog history</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The ETE tutorial</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">Working With Tree Data Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#trees">Trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-writing-newick-trees">Reading and Writing Newick Trees</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reading-newick-trees">Reading newick trees</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-newick-trees">Writing newick trees</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#understanding-ete-trees">Understanding ETE Trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-tree-attributes">Basic tree attributes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#root-node-on-unrooted-trees">Root node on unrooted trees?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#browsing-trees-traversing">Browsing trees (traversing)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#getting-leaves-descendants-and-node-s-relatives">Getting Leaves, Descendants and Node&#8217;s Relatives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#traversing-browsing-trees">Traversing (browsing) trees</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-traversing-stopping-criteria">Advanced traversing (stopping criteria)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterating-instead-of-getting">Iterating instead of Getting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#finding-nodes-by-their-attributes">Finding nodes by their attributes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#checking-the-monophyly-of-attributes-within-a-tree">Checking the monophyly of attributes within a tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#caching-tree-content-for-faster-lookup-operations">Caching tree content for faster lookup operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node-annotation">Node annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comparing-trees">Comparing Trees</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#calculate-distances-between-trees">Calculate distances between trees</a></li>
<li class="toctree-l4"><a class="reference internal" href="#robinson-foulds-distance">Robinson-foulds distance</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-tree-topology">Modifying Tree Topology</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-trees-from-scratch">Creating Trees from Scratch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-eliminating-and-removing-detaching-nodes">Deleting (eliminating) and Removing (detaching) nodes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pruning-trees">Pruning trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concatenating-trees">Concatenating trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copying-duplicating-trees">Copying (duplicating) trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving-multifurcations">Solving multifurcations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tree-rooting">Tree Rooting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-branch-distances">Working with branch distances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#getting-distances-between-nodes">Getting distances between nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#getting-midpoint-outgroup">getting midpoint outgroup</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_drawing.html">The Programmable Tree Drawing Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_phylogeny.html">Phylogenetic Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_clustering.html">Clustering Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_xml.html">Phylogenetic XML standards</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_webplugin.html">Interactive web tree visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_adaptation.html">Testing Evolutionary Hypothesis</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_ncbitaxonomy.html">Dealing with the NCBI Taxonomy database</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_etree2orthoxml.html">SCRIPTS: orthoXML</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">ETE&#8217;s Reference Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">ETE Toolkit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The ETE tutorial</a> &raquo;</li>
      
    <li>Working With Tree Data Structures</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/tutorial/tutorial_trees.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-ete3"></span><div class="section" id="working-with-tree-data-structures">
<h1><a class="toc-backref" href="#id3">Working With Tree Data Structures</a><a class="headerlink" href="#working-with-tree-data-structures" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#working-with-tree-data-structures" id="id3">Working With Tree Data Structures</a><ul>
<li><a class="reference internal" href="#trees" id="id4">Trees</a></li>
<li><a class="reference internal" href="#reading-and-writing-newick-trees" id="id5">Reading and Writing Newick Trees</a><ul>
<li><a class="reference internal" href="#reading-newick-trees" id="id6">Reading newick trees</a></li>
<li><a class="reference internal" href="#writing-newick-trees" id="id7">Writing newick trees</a></li>
</ul>
</li>
<li><a class="reference internal" href="#understanding-ete-trees" id="id8">Understanding ETE Trees</a></li>
<li><a class="reference internal" href="#basic-tree-attributes" id="id9">Basic tree attributes</a><ul>
<li><a class="reference internal" href="#root-node-on-unrooted-trees" id="id10">Root node on unrooted trees?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#browsing-trees-traversing" id="id11">Browsing trees (traversing)</a><ul>
<li><a class="reference internal" href="#getting-leaves-descendants-and-node-s-relatives" id="id12">Getting Leaves, Descendants and Node&#8217;s Relatives</a></li>
<li><a class="reference internal" href="#traversing-browsing-trees" id="id13">Traversing (browsing) trees</a></li>
<li><a class="reference internal" href="#advanced-traversing-stopping-criteria" id="id14">Advanced traversing (stopping criteria)</a><ul>
<li><a class="reference internal" href="#collapsing-nodes-while-traversing-custom-is-leaf-definition" id="id15">Collapsing nodes while traversing (custom is_leaf definition)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterating-instead-of-getting" id="id16">Iterating instead of Getting</a></li>
<li><a class="reference internal" href="#finding-nodes-by-their-attributes" id="id17">Finding nodes by their attributes</a><ul>
<li><a class="reference internal" href="#search-all-nodes-matching-a-given-criteria" id="id18">Search_all nodes matching a given criteria</a></li>
<li><a class="reference internal" href="#search-nodes-matching-a-given-criteria-iteration" id="id19">Search nodes matching a given criteria (iteration)</a></li>
<li><a class="reference internal" href="#find-the-first-common-ancestor" id="id20">Find the first common ancestor</a></li>
<li><a class="reference internal" href="#custom-searching-functions" id="id21">Custom searching functions</a></li>
<li><a class="reference internal" href="#shortcuts" id="id22">Shortcuts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#checking-the-monophyly-of-attributes-within-a-tree" id="id23">Checking the monophyly of attributes within a tree</a></li>
<li><a class="reference internal" href="#caching-tree-content-for-faster-lookup-operations" id="id24">Caching tree content for faster lookup operations</a></li>
<li><a class="reference internal" href="#node-annotation" id="id25">Node annotation</a></li>
<li><a class="reference internal" href="#comparing-trees" id="id26">Comparing Trees</a><ul>
<li><a class="reference internal" href="#calculate-distances-between-trees" id="id27">Calculate distances between trees</a></li>
<li><a class="reference internal" href="#robinson-foulds-distance" id="id28">Robinson-foulds distance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifying-tree-topology" id="id29">Modifying Tree Topology</a><ul>
<li><a class="reference internal" href="#creating-trees-from-scratch" id="id30">Creating Trees from Scratch</a></li>
<li><a class="reference internal" href="#deleting-eliminating-and-removing-detaching-nodes" id="id31">Deleting (eliminating) and Removing (detaching) nodes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pruning-trees" id="id32">Pruning trees</a></li>
<li><a class="reference internal" href="#concatenating-trees" id="id33">Concatenating trees</a></li>
<li><a class="reference internal" href="#copying-duplicating-trees" id="id34">Copying (duplicating) trees</a></li>
<li><a class="reference internal" href="#solving-multifurcations" id="id35">Solving multifurcations</a></li>
<li><a class="reference internal" href="#tree-rooting" id="id36">Tree Rooting</a></li>
<li><a class="reference internal" href="#working-with-branch-distances" id="id37">Working with branch distances</a><ul>
<li><a class="reference internal" href="#getting-distances-between-nodes" id="id38">Getting distances between nodes</a></li>
<li><a class="reference internal" href="#getting-midpoint-outgroup" id="id39">getting midpoint outgroup</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="trees">
<h2><a class="toc-backref" href="#id4">Trees</a><a class="headerlink" href="#trees" title="Permalink to this headline">¶</a></h2>
<p>Trees are a widely-used type of data structure that emulates a tree
design with a set of linked nodes.  Formally, a tree is considered an
acyclic and connected graph. Each node in a tree has zero or more
child nodes, which are below it in the tree (by convention, trees grow
down, not up as they do in nature). A node that has a child is called
the child&#8217;s parent node (or ancestor node, or superior). A node has at
most one parent.</p>
<p>The height of a node is the length of the longest downward path to a
leaf from that node. The height of the root is the height of the
tree. The depth of a node is the length of the path to its root (i.e.,
its root path).</p>
<ul class="simple">
<li>The topmost node in a tree is called the root node. Being the
topmost node, the root node will not have parents. It is the node at
which operations on the tree commonly begin (although some
algorithms begin with the leaf nodes and work up ending at the
root). All other nodes can be reached from it by following edges or
links. Every node in a tree can be seen as the root node of the
subtree rooted at that node.</li>
<li>Nodes at the bottommost level of the tree are called leaf
nodes. Since they are at the bottommost level, they do not have any
children.</li>
<li>An internal node or inner node is any node of a tree that has child
nodes and is thus not a leaf node.</li>
<li>A subtree is a portion of a tree data structure that can be viewed
as a complete tree in itself. Any node in a tree T, together with
all the nodes below it, comprise a subtree of T. The subtree
corresponding to the root node is the entire tree; the subtree
corresponding to any other node is called a proper subtree (in
analogy to the term proper subset).</li>
</ul>
<p>In bioinformatics, trees are the result of many analyses, such as
phylogenetics or clustering. Although each case entails specific
considerations, many properties remains constant among them. In this
respect, ETE is a python toolkit that assists in the automated
manipulation, analysis and visualization of any type of hierarchical
trees. It provides general methods to handle and visualize tree
topologies, as well as specific modules to deal with phylogenetic and
clustering trees.</p>
</div>
<div class="section" id="reading-and-writing-newick-trees">
<span id="sec-newick-formats"></span><h2><a class="toc-backref" href="#id5">Reading and Writing Newick Trees</a><a class="headerlink" href="#reading-and-writing-newick-trees" title="Permalink to this headline">¶</a></h2>
<p>The Newick format is one of the most widely used standard
representation of trees in bioinformatics. It uses nested parentheses
to represent hierarchical data structures as text strings. The
original newick standard is able to encode information about the tree
topology, branch distances and node names. Nevertheless, it is not
uncommon to find slightly different formats using the newick standard.</p>
<p>ETE can read and write many of them:</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="33%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FORMAT</th>
<th class="head">DESCRIPTION</th>
<th class="head">SAMPLE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>flexible with support values</td>
<td>((D:0.723274,F:0.567784)1.000000:0.067192,(B:0.279326,H:0.756049)1.000000:0.807788);</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>flexible with internal node names</td>
<td>((D:0.723274,F:0.567784)E:0.067192,(B:0.279326,H:0.756049)B:0.807788);</td>
</tr>
<tr class="row-even"><td>2</td>
<td>all branches + leaf names + internal supports</td>
<td>((D:0.723274,F:0.567784)1.000000:0.067192,(B:0.279326,H:0.756049)1.000000:0.807788);</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>all branches + all names</td>
<td>((D:0.723274,F:0.567784)E:0.067192,(B:0.279326,H:0.756049)B:0.807788);</td>
</tr>
<tr class="row-even"><td>4</td>
<td>leaf branches + leaf names</td>
<td>((D:0.723274,F:0.567784),(B:0.279326,H:0.756049));</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>internal and leaf branches + leaf names</td>
<td>((D:0.723274,F:0.567784):0.067192,(B:0.279326,H:0.756049):0.807788);</td>
</tr>
<tr class="row-even"><td>6</td>
<td>internal branches + leaf names</td>
<td>((D,F):0.067192,(B,H):0.807788);</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>leaf branches + all names</td>
<td>((D:0.723274,F:0.567784)E,(B:0.279326,H:0.756049)B);</td>
</tr>
<tr class="row-even"><td>8</td>
<td>all names</td>
<td>((D,F)E,(B,H)B);</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>leaf names</td>
<td>((D,F),(B,H));</td>
</tr>
<tr class="row-even"><td>100</td>
<td>topology only</td>
<td>((,),(,));</td>
</tr>
</tbody>
</table>
<p>Formats labeled as <em>flexible</em> allow for missing information. For
instance, format 0 will be able to load a newick tree even if it does
not contain branch support information (it will be initialized with
the default value). However, format 2 would raise an exception.  In
other words, if you want to control that your newick files strictly
follow a given pattern you should use <strong>strict</strong> format definitions.</p>
<div class="section" id="reading-newick-trees">
<h3><a class="toc-backref" href="#id6">Reading newick trees</a><a class="headerlink" href="#reading-newick-trees" title="Permalink to this headline">¶</a></h3>
<p>In order to load a tree from a newick text string you can use the
constructor <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode" title="ete3.TreeNode"><code class="xref py py-class docutils literal"><span class="pre">TreeNode</span></code></a> or its <a class="reference internal" href="../reference/reference_tree.html#ete3.Tree" title="ete3.Tree"><code class="xref py py-class docutils literal"><span class="pre">Tree</span></code></a> alias, provided by the main module
<a class="reference internal" href="#module-ete3" title="ete3: provides main objects and modules"><code class="xref py py-mod docutils literal"><span class="pre">ete3</span></code></a>. You will only need to pass a text string containing
the newick structure and the format that should be used to parse it (0
by default). Alternatively, you can pass the path to a text file
containing the newick string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree structure from a newick string. The returned variable ’t’ is the root node for the tree.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1):0.5):0.5);&quot;</span> <span class="p">)</span>

<span class="c"># Load a tree structure from a newick file.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;genes_tree.nh&quot;</span><span class="p">)</span>

<span class="c"># You can also specify the newick format. For instance, for named internal nodes we will use format 1.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1)Internal_1:0.5)Internal_2:0.5)Root;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-newick-trees">
<h3><a class="toc-backref" href="#id7">Writing newick trees</a><a class="headerlink" href="#writing-newick-trees" title="Permalink to this headline">¶</a></h3>
<p>Any ETE tree instance can be exported using newick notation using the
<code class="xref py py-func docutils literal"><span class="pre">Tree.write()</span></code> method, which is available in any tree node
instance. It also allows for format selection
(<a class="reference internal" href="#sec-newick-formats"><span>Reading and Writing Newick Trees</span></a>), so you can use the same function to
convert between newick formats.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree with internal node names</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(A:1,(B:1,(E:1,D:1)Internal_1:0.5)Internal_2:0.5)Root;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># And prints its newick using the default format</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">()</span> <span class="c"># (A:1.000000,(B:1.000000,(E:1.000000,D:1.000000)1.000000:0.500000)1.000000:0.500000);</span>

<span class="c"># To print the internal node names you need to change the format:</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># (A:1.000000,(B:1.000000,(E:1.000000,D:1.000000)Internal_1:0.500000)Internal_2:0.500000);</span>

<span class="c"># We can also write into a file</span>
<span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s">&quot;new_tree.nw&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="understanding-ete-trees">
<h2><a class="toc-backref" href="#id8">Understanding ETE Trees</a><a class="headerlink" href="#understanding-ete-trees" title="Permalink to this headline">¶</a></h2>
<p>Any tree topology can be represented as a succession of <strong>nodes</strong>
connected in a hierarchical way. Thus, for practical reasons, ETE
makes no distinction between tree and node concepts, as any tree can
be represented by its root node. This allows to use any internal node
within a tree as another sub-tree instance.</p>
<p>Once trees are loaded, they can be manipulated as normal python
objects. Given that a tree is actually a collection of nodes connected
in a hierarchical way, what you usually see as a tree will be the root
node instance from which the tree structure is hanging. However, every
node within a ETE&#8217;s tree structure can be also considered a
subtree. This means, for example, that all the operational methods
that we will review in the following sections are available at any
possible level within a tree. Moreover, this feature will allow you to
separate large trees into smaller partitions, or concatenate several
trees into a single structure. For this reason, you will find that the
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode" title="ete3.TreeNode"><code class="xref py py-class docutils literal"><span class="pre">TreeNode</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.Tree" title="ete3.Tree"><code class="xref py py-class docutils literal"><span class="pre">Tree</span></code></a> classes are synonymous.</p>
</div>
<div class="section" id="basic-tree-attributes">
<h2><a class="toc-backref" href="#id9">Basic tree attributes</a><a class="headerlink" href="#basic-tree-attributes" title="Permalink to this headline">¶</a></h2>
<p>Each tree node has two basic attributes used to establish its position
in the tree: <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.up" title="ete3.TreeNode.up"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.up</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.children" title="ete3.TreeNode.children"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.children</span></code></a>.  The first is
a pointer to parent&#8217;s node, while the later is a list of children
nodes.  Although it is possible to modify the structure of a tree by
changing these attributes, it is strongly recommend not to do
it. Several methods are provided to manipulate each node&#8217;s connections
in a safe way (see <a class="reference internal" href="#sec-modifying-tree-topology"><span>Comparing Trees</span></a>).</p>
<p>In addition, three other basic attributes are always present in any
tree node instance:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="69%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
<th class="head">Default value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.dist" title="ete3.TreeNode.dist"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></code></a></td>
<td>stores the distance from the node to its parent (branch length). Default value = 1.0</td>
<td>1.0</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.support" title="ete3.TreeNode.support"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.support</span></code></a></td>
<td>informs about the reliability of the partition defined by the node (i.e. bootstrap support)</td>
<td>1.0</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.name</span></code></td>
<td>Custom node&#8217;s name.</td>
<td>NoName</td>
</tr>
</tbody>
</table>
<p>In addition, several methods are provided to perform basic operations
on tree node instances:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.is_leaf" title="ete3.TreeNode.is_leaf"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.is_leaf()</span></code></a></td>
<td>returns True if <em>node</em> has no children</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.is_root" title="ete3.TreeNode.is_root"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.is_root()</span></code></a></td>
<td>returns True if <em>node</em> has no parent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_tree_root" title="ete3.TreeNode.get_tree_root"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_tree_root()</span></code></a></td>
<td>returns the top-most node within the same tree structure as <em>node</em></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">len(TreeNode)</span></code></td>
<td>returns the number of leaves under <em>node</em></td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">print</span> <span class="pre">node</span></code></td>
<td>prints a text-based representation of the tree topology under <em>node</em></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">if</span> <span class="pre">node</span> <span class="pre">in</span> <span class="pre">tree</span></code></td>
<td>returns true if <em>node</em> is a leaf under <em>tree</em></td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">for</span> <span class="pre">leaf</span> <span class="pre">in</span> <span class="pre">node</span></code></td>
<td>iterates over all leaves under <em>node</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.show" title="ete3.TreeNode.show"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.show()</span></code></a></td>
<td>Explore node graphically using a GUI.</td>
</tr>
</tbody>
</table>
<p>This is an example on how to access such attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="c"># We create a random tree topology</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">up</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">dist</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
<span class="c"># You can also iterate over tree leaves using a simple syntax</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
  <span class="k">print</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<div class="section" id="root-node-on-unrooted-trees">
<h3><a class="toc-backref" href="#id10">Root node on unrooted trees?</a><a class="headerlink" href="#root-node-on-unrooted-trees" title="Permalink to this headline">¶</a></h3>
<p>When a tree is loaded from external sources, a pointer to the top-most
node is returned. This is called the tree root, and <strong>it will exist
even if the tree is conceptually considered as unrooted</strong>. This is,
the root node can be considered as the master node, since it
represents the whole tree structure. Unrooted trees can be identified
as trees in which master root node has more than two children.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">unrooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;(A,B,(C,D));&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">unrooted_tree</span>
<span class="c">#</span>
<span class="c">#     /-A</span>
<span class="c">#    |</span>
<span class="c">#----|--B</span>
<span class="c">#    |</span>
<span class="c">#    |     /-C</span>
<span class="c">#     \---|</span>
<span class="c">#          \-D</span>

<span class="n">rooted_tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;((A,B),(C,D));&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">rooted_tree</span>
<span class="c">#</span>
<span class="c">#          /-A</span>
<span class="c">#     /---|</span>
<span class="c">#    |     \-B</span>
<span class="c">#----|</span>
<span class="c">#    |     /-C</span>
<span class="c">#     \---|</span>
<span class="c">#          \-D</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="browsing-trees-traversing">
<h2><a class="toc-backref" href="#id11">Browsing trees (traversing)</a><a class="headerlink" href="#browsing-trees-traversing" title="Permalink to this headline">¶</a></h2>
<p>One of the most basic operations for tree analysis is <em>tree
browsing</em>. This is, essentially, visiting nodes within a tree. ETE
provides a number of methods to search for specific nodes or to
navigate over the hierarchical structure of a tree.</p>
<div class="section" id="getting-leaves-descendants-and-node-s-relatives">
<h3><a class="toc-backref" href="#id12">Getting Leaves, Descendants and Node&#8217;s Relatives</a><a class="headerlink" href="#getting-leaves-descendants-and-node-s-relatives" title="Permalink to this headline">¶</a></h3>
<p>TreeNode instances contain several functions to access their
descendants. Available methods are self explanatory:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
</div>
<div class="section" id="traversing-browsing-trees">
<h3><a class="toc-backref" href="#id13">Traversing (browsing) trees</a><a class="headerlink" href="#traversing-browsing-trees" title="Permalink to this headline">¶</a></h3>
<p>Often, when processing trees, all nodes need to be visited. This is
called tree traversing. There are different ways to traverse a tree
structure depending on the order in which children nodes are
visited. ETE implements the three most common strategies:
<strong>preorder</strong>, <strong>levelorder</strong> and <strong>postorder</strong>. The following scheme
shows the differences in the strategy for visiting nodes (note that in
both cases the whole tree is browsed):</p>
<ul class="simple">
<li>preorder: 1)Visit the root, 2) Traverse the left subtree , 3) Traverse the right subtree.</li>
<li>postorder: 1) Traverse the left subtree , 2) Traverse the right subtree, 3) Visit the root</li>
<li>levelorder (default): every node on a level before is visited going to a lower level</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Preorder traversal sequence: F, B, A, D, C, E, G, I, H (root, left, right)</li>
<li>Inorder traversal sequence: A, B, C, D, E, F, G, H, I (left, root, right); note how this produces a sorted sequence</li>
<li>Postorder traversal sequence: A, C, E, D, B, H, I, G, F (left, right, root)</li>
<li>Level-order traversal sequence: F, B, G, A, D, I, C, E, H</li>
</ul>
</div>
<p>Every node in a tree includes a <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.traverse" title="ete3.TreeNode.traverse"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.traverse()</span></code></a> method, which can be
used to visit, one by one, every node node under the current
partition. In addition, the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_descendants" title="ete3.TreeNode.iter_descendants"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></code></a> method can be set
to use either a post- or a preorder strategy.  The only different
between <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.traverse" title="ete3.TreeNode.traverse"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.traverse()</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_descendants" title="ete3.TreeNode.iter_descendants"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></code></a> is that the
first will include the root node in the iteration.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>strategy</strong> can take one of the following values: <code class="docutils literal"><span class="pre">&quot;postorder&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;preorder&quot;</span></code> or  <code class="docutils literal"><span class="pre">&quot;levelorder&quot;</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># we load a tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s">&quot;postorder&quot;</span><span class="p">):</span>
  <span class="c"># Do some analysis on node</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

<span class="c"># If we want to iterate over a tree excluding the root node, we can</span>
<span class="c"># use the iter_descendant method</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">(</span><span class="s">&quot;postorder&quot;</span><span class="p">):</span>
  <span class="c"># Do some analysis on node</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>Additionally, you can implement your own traversing function using the
structural attributes of nodes. In the following example, only nodes
between a given leaf and the tree root are visited.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;(A:1,(B:1,(C:1,D:1):0.5):0.5);&quot;</span> <span class="p">)</span>

<span class="c"># Browse the tree from a specific leaf to the root</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">while</span> <span class="n">node</span><span class="p">:</span>
   <span class="k">print</span> <span class="n">node</span>
   <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-traversing-stopping-criteria">
<h3><a class="toc-backref" href="#id14">Advanced traversing (stopping criteria)</a><a class="headerlink" href="#advanced-traversing-stopping-criteria" title="Permalink to this headline">¶</a></h3>
<div class="section" id="collapsing-nodes-while-traversing-custom-is-leaf-definition">
<span id="is-leaf-fn"></span><h4><a class="toc-backref" href="#id15">Collapsing nodes while traversing (custom is_leaf definition)</a><a class="headerlink" href="#collapsing-nodes-while-traversing-custom-is-leaf-definition" title="Permalink to this headline">¶</a></h4>
<p>From version 2.2, ETE supports the use of the <code class="xref py py-attr docutils literal"><span class="pre">is_leaf_fn</span></code>
argument in most of its traversing functions. The value of
<code class="xref py py-attr docutils literal"><span class="pre">is_leaf_fn</span></code> is expected to be a pointer to any python function
that accepts a node instance as its first argument and returns a
boolean value (True if node should be considered a leaf node).</p>
<p>By doing so, all traversing methods will use such a custom function to
decide if a node is a leaf. This becomes specially useful when dynamic
collapsing of nodes is needed, thus avoiding to prune the same tree in
many different ways.</p>
<p>For instance, given a large tree structure, the following code will
export the newick of the pruned version of the topology, where nodes
grouping the same tip labels are collapsed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="k">def</span> <span class="nf">collapsed_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node2labels</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">False</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((((a,a,a)a,a)aa, (b,b)b)ab, (c, (d,d)d)cd);&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c"># We create a cache with every node content</span>
<span class="n">node2labels</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="n">store_attr</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">collapsed_leaf</span><span class="p">)</span>
<span class="c">#             /-a</span>
<span class="c">#            |</span>
<span class="c">#          /-|--a</span>
<span class="c">#         |  |</span>
<span class="c">#       /-|   \-a</span>
<span class="c">#      |  |</span>
<span class="c">#    /-|   \-a</span>
<span class="c">#   |  |</span>
<span class="c">#   |  |   /-b</span>
<span class="c"># --|   \-|</span>
<span class="c">#   |      \-b</span>
<span class="c">#   |</span>
<span class="c">#   |   /-c</span>
<span class="c">#    \-|</span>
<span class="c">#      |   /-d</span>
<span class="c">#       \-|</span>
<span class="c">#          \-d</span>

<span class="c"># We can even load the collapsed version as a new tree</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">collapsed_leaf</span><span class="p">)</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">t2</span>
<span class="c">#       /-aa</span>
<span class="c">#    /-|</span>
<span class="c">#   |   \-b</span>
<span class="c"># --|</span>
<span class="c">#   |   /-c</span>
<span class="c">#    \-|</span>
<span class="c">#       \-d</span>
</pre></div>
</div>
<p>Another interesting use of this approach is to find the first matching
nodes in a given tree that match a custom set of criteria, without
browsing the whole tree structure.</p>
<p>Let&#8217;s say we want get all deepest nodes in a tree whose branch length
is larger than one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(((a,b)ab:2, (c, d)cd:2)abcd:2, ((e, f):2, g)efg:2);&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">processable_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">False</span>

<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">processable_node</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">leaf</span>

<span class="c">#       /-a</span>
<span class="c">#    /-|</span>
<span class="c">#   |   \-b</span>
<span class="c"># --|</span>
<span class="c">#   |   /-c</span>
<span class="c">#    \-|</span>
<span class="c">#       \-d</span>
<span class="c">#</span>
<span class="c">#       /-e</span>
<span class="c">#    /-|</span>
<span class="c"># --|   \-f</span>
<span class="c">#   |</span>
<span class="c">#    \-g</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterating-instead-of-getting">
<h3><a class="toc-backref" href="#id16">Iterating instead of Getting</a><a class="headerlink" href="#iterating-instead-of-getting" title="Permalink to this headline">¶</a></h3>
<p>As commented previously, methods starting with <strong>get_</strong> are all
prepared to return results as a closed list of items. This means, for
instance, that if you want to process all tree leaves and you ask for
them using the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_leaves" title="ete3.TreeNode.get_leaves"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_leaves()</span></code></a> method, the whole tree
structure will be browsed before returning the final list of terminal
nodes.  This is not a problem in most of the cases, but in large
trees, you can speed up the browsing process by using iterators.</p>
<p>Most <strong>get_</strong> methods have their homologous iterator functions. Thus,
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_leaves" title="ete3.TreeNode.get_leaves"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_leaves()</span></code></a> could be substituted by <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_leaves" title="ete3.TreeNode.iter_leaves"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_leaves()</span></code></a>. The same
occurs with <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_descendants" title="ete3.TreeNode.iter_descendants"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_descendants()</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_search_nodes" title="ete3.TreeNode.iter_search_nodes"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_search_nodes()</span></code></a>.</p>
<p>When iterators are used (note that is only applicable for looping),
only one step is processed at a time. For instance,
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.iter_search_nodes" title="ete3.TreeNode.iter_search_nodes"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.iter_search_nodes()</span></code></a> will return one match in each
iteration. In practice, this makes no differences in the final result,
but it may increase the performance of loop functions (i.e. in case of
finding a match which interrupts the loop).</p>
</div>
<div class="section" id="finding-nodes-by-their-attributes">
<h3><a class="toc-backref" href="#id17">Finding nodes by their attributes</a><a class="headerlink" href="#finding-nodes-by-their-attributes" title="Permalink to this headline">¶</a></h3>
<p>Both terminal and internal nodes can be located by searching along the
tree structure. Several methods are available:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>t.search_nodes(attr=value)</td>
<td>Returns a list of nodes in which attr is equal to value, i.e. name=A</td>
</tr>
<tr class="row-odd"><td>t.iter_search_nodes(attr=value)</td>
<td>Iterates over all matching nodes matching attr=value. Faster when you only need to get the first occurrence</td>
</tr>
<tr class="row-even"><td>t.get_leaves_by_name(name)</td>
<td>Returns a list of leaf nodes matching a given name. Only leaves are browsed.</td>
</tr>
<tr class="row-odd"><td>t.get_common_ancestor([node1, node2, node3])</td>
<td>Return the first internal node grouping node1, node2 and node3</td>
</tr>
<tr class="row-even"><td>t&amp;&#8221;A&#8221;</td>
<td>Shortcut for t.search_nodes(name=&#8221;A&#8221;)[0]</td>
</tr>
</tbody>
</table>
<div class="section" id="search-all-nodes-matching-a-given-criteria">
<h4><a class="toc-backref" href="#id18">Search_all nodes matching a given criteria</a><a class="headerlink" href="#search-all-nodes-matching-a-given-criteria" title="Permalink to this headline">¶</a></h4>
<p>A custom list of nodes matching a given name can be easily obtain
through the <code class="xref py py-func docutils literal"><span class="pre">TreeNode.search_node()</span></code> function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&#39;((H:1,I:1):0.5, A:1, (B:1,(C:1,D:1):0.5):0.5);&#39;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                    /-H</span>
<span class="c">#          /--------|</span>
<span class="c">#         |          \-I</span>
<span class="c">#         |</span>
<span class="c">#---------|--A</span>
<span class="c">#         |</span>
<span class="c">#         |          /-B</span>
<span class="c">#          \--------|</span>
<span class="c">#                   |          /-C</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>

<span class="c"># I get D</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c"># I get all nodes with distance=0.5</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="s">&quot;nodes have distance=0.5&quot;</span>

<span class="c"># We can limit the search to leaves and node names (faster method).</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_leaves_by_name</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">D</span>
</pre></div>
</div>
</div>
<div class="section" id="search-nodes-matching-a-given-criteria-iteration">
<h4><a class="toc-backref" href="#id19">Search nodes matching a given criteria (iteration)</a><a class="headerlink" href="#search-nodes-matching-a-given-criteria-iteration" title="Permalink to this headline">¶</a></h4>
<p>A limitation of the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.search_nodes" title="ete3.TreeNode.search_nodes"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.search_nodes()</span></code></a> method is that you cannot use
complex conditional statements to find specific nodes.  When search
criteria is too complex, you may need to create your own search
function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="k">def</span> <span class="nf">search_by_size</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="s">&quot;Finds nodes with a given number of leaves&quot;</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
          <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="c"># returns nodes containing 6 leaves</span>
<span class="n">search_by_size</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="find-the-first-common-ancestor">
<h4><a class="toc-backref" href="#id20">Find the first common ancestor</a><a class="headerlink" href="#find-the-first-common-ancestor" title="Permalink to this headline">¶</a></h4>
<p>Searching for the first common ancestor of a given set of nodes it is
a handy way of finding internal nodes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:0.5,(J:1.3, (F:1.2, D:0.1):0.5):0.5):0.5):0.5);&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-searching-functions">
<h4><a class="toc-backref" href="#id21">Custom searching functions</a><a class="headerlink" href="#custom-searching-functions" title="Permalink to this headline">¶</a></h4>
<p>A limitation of the previous methods is that you cannot use complex
conditional statements to find specific nodes. However you can user
traversing methods to meet your custom filters. A possible general
strategy would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:1,D:1):0.5):0.5);&quot;</span><span class="p">)</span>
<span class="c"># Create a small function to filter your nodes</span>
<span class="k">def</span> <span class="nf">conditional_function</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="c"># Use previous function to find matches. Note that we use the traverse</span>
<span class="c"># method in the filter function. This will iterate over all nodes to</span>
<span class="c"># assess if they meet our custom conditions and will return a list of</span>
<span class="c"># matches.</span>
<span class="n">matches</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">conditional_function</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">())</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span> <span class="s">&quot;nodes have distance &gt;0.3&quot;</span>

<span class="c"># depending on the complexity of your conditions you can do the same</span>
<span class="c"># in just one line with the help of lambda functions:</span>
<span class="n">matches</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">0.3</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="p">)</span>
<span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">),</span> <span class="s">&quot;nodes have distance &gt;0.3 and are leaves&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="shortcuts">
<h4><a class="toc-backref" href="#id22">Shortcuts</a><a class="headerlink" href="#shortcuts" title="Permalink to this headline">¶</a></h4>
<p>Finally, ETE implements a built-in method to find the first node
matching a given name, which is one of the most common tasks needed
for tree analysis. This can be done through the operator &amp;
(AND). Thus, TreeNode&amp;”A” will always return the first node whose name
is “A” and that is under the tree “MyTree”. The syntaxis may seem
confusing, but it can be very useful in some situations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:1,(J:1, (F:1, D:1):0.5):0.5):0.5):0.5);&quot;</span><span class="p">)</span>
<span class="c"># Get the node D in a very simple way</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;D&quot;</span>
<span class="c"># Get the path from B to the root</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">D</span>
<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
  <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
  <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c"># I substract D node from the total number of visited nodes</span>
<span class="k">print</span> <span class="s">&quot;There are&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;nodes between D and the root&quot;</span>
<span class="c"># Using parentheses you can use by-operand search syntax as a node</span>
<span class="c"># instance itself</span>
<span class="n">Dsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="n">Bsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;B&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="n">Jsparent</span><span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;J&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">up</span>
<span class="c"># I check if nodes belong to certain partitions</span>
<span class="k">print</span> <span class="s">&quot;It is&quot;</span><span class="p">,</span> <span class="n">Dsparent</span> <span class="ow">in</span> <span class="n">Bsparent</span><span class="p">,</span> <span class="s">&quot;that C&#39;s parent is under B&#39;s ancestor&quot;</span>
<span class="k">print</span> <span class="s">&quot;It is&quot;</span><span class="p">,</span> <span class="n">Dsparent</span> <span class="ow">in</span> <span class="n">Jsparent</span><span class="p">,</span> <span class="s">&quot;that C&#39;s parent is under J&#39;s ancestor&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="checking-the-monophyly-of-attributes-within-a-tree">
<span id="check-monophyly"></span><h2><a class="toc-backref" href="#id23">Checking the monophyly of attributes within a tree</a><a class="headerlink" href="#checking-the-monophyly-of-attributes-within-a-tree" title="Permalink to this headline">¶</a></h2>
<p>Although monophyly is actually a phylogenetic concept used to refer to
a set of species that group exclusively together within a tree
partition, the idea can be easily exported to any type of trees.</p>
<p>Therefore, we could consider that a set of values for a given node
attribute present in our tree is monophyletic, if such values group
exclusively together as a single tree partition. If not, the
corresponding relationship connecting such values (para or
poly-phyletic) could be also be inferred.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.check_monophyly" title="ete3.TreeNode.check_monophyly"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.check_monophyly()</span></code></a> method will do so when a given
tree is queried for any custom attribute.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span>  <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((((((a, e), i), o),h), u), ((f, g), j));&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>

<span class="c">#                   /-a</span>
<span class="c">#                /-|</span>
<span class="c">#             /-|   \-e</span>
<span class="c">#            |  |</span>
<span class="c">#          /-|   \-i</span>
<span class="c">#         |  |</span>
<span class="c">#       /-|   \-o</span>
<span class="c">#      |  |</span>
<span class="c">#    /-|   \-h</span>
<span class="c">#   |  |</span>
<span class="c">#   |   \-u</span>
<span class="c"># --|</span>
<span class="c">#   |      /-f</span>
<span class="c">#   |   /-|</span>
<span class="c">#    \-|   \-g</span>
<span class="c">#      |</span>
<span class="c">#       \-j</span>


<span class="c"># We can check how, indeed, all vowels are not monophyletic in the</span>
<span class="c"># previous tree, but polyphyletic (a foreign label breaks its monophyly)</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">)</span>

<span class="c"># however, the following set of vowels are monophyletic</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">)</span>

<span class="c"># A special case of polyphyly, called paraphyly, is also used to</span>
<span class="c"># define certain type of grouping. See this wikipedia article for</span>
<span class="c"># disambiguation: http://en.wikipedia.org/wiki/Paraphyly</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">check_monophyly</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;o&quot;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_monophyletic" title="ete3.TreeNode.get_monophyletic"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_monophyletic()</span></code></a> method is also
provided, which allows to return a list of nodes within a tree where a
given set of attribute values are monophyletic. Note that, although a
set of values are not monophyletic regarding the whole tree, several
independent monophyletic partitions could be found within the same
topology.</p>
<p>For instance, in the following example, all clusters within the same
tree exclusively grouping a custom set of annotations are obtained.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span>  <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((((((4, e), i), o),h), u), ((3, 4), (i, june)));&quot;</span><span class="p">)</span>
<span class="c"># we annotate the tree using external data</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">:</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">:</span><span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">:</span><span class="s">&quot;yellow&quot;</span><span class="p">,</span>
          <span class="s">&quot;o&quot;</span><span class="p">:</span><span class="s">&quot;black&quot;</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">:</span><span class="s">&quot;purple&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">:</span><span class="s">&quot;green&quot;</span><span class="p">,</span>
          <span class="s">&quot;3&quot;</span><span class="p">:</span><span class="s">&quot;yellow&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">:</span><span class="s">&quot;white&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">:</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
          <span class="s">&quot;june&quot;</span><span class="p">:</span><span class="s">&quot;yellow&quot;</span><span class="p">}</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">))</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;color&quot;</span><span class="p">],</span> <span class="n">show_internal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c">#                   /-4, green</span>
<span class="c">#                /-|</span>
<span class="c">#             /-|   \-e, green</span>
<span class="c">#            |  |</span>
<span class="c">#          /-|   \-i, yellow</span>
<span class="c">#         |  |</span>
<span class="c">#       /-|   \-o, black</span>
<span class="c">#      |  |</span>
<span class="c">#    /-|   \-h, none</span>
<span class="c">#   |  |</span>
<span class="c">#   |   \-u, purple</span>
<span class="c"># --|</span>
<span class="c">#   |      /-3, yellow</span>
<span class="c">#   |   /-|</span>
<span class="c">#   |  |   \-4, green</span>
<span class="c">#    \-|</span>
<span class="c">#      |   /-i, yellow</span>
<span class="c">#       \-|</span>
<span class="c">#          \-june, yellow</span>

<span class="k">print</span> <span class="s">&quot;Green-yellow clusters:&quot;</span>
<span class="c"># And obtain clusters exclusively green and yellow</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">get_monophyletic</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="s">&quot;yellow&quot;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s">&quot;color&quot;</span><span class="p">):</span>
   <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;color&quot;</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">],</span> <span class="n">show_internal</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># Green-yellow clusters:</span>
<span class="c">#</span>
<span class="c">#       /-green, 4</span>
<span class="c">#    /-|</span>
<span class="c"># --|   \-green, e</span>
<span class="c">#   |</span>
<span class="c">#    \-yellow, i</span>
<span class="c">#</span>
<span class="c">#       /-yellow, 3</span>
<span class="c">#    /-|</span>
<span class="c">#   |   \-green, 4</span>
<span class="c"># --|</span>
<span class="c">#   |   /-yellow, i</span>
<span class="c">#    \-|</span>
<span class="c">#       \-yellow, june</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When the target attribute is set to the &#8220;species&#8221; feature name,
associated to any <a class="reference internal" href="../reference/reference_phylo.html#ete3.PhyloTree" title="ete3.PhyloTree"><code class="xref py py-class docutils literal"><span class="pre">PhyloTree</span></code></a> node, this method will
accomplish with the standard phylogenetic definition of monophyly,
polyphyly and paraphyly.</p>
</div>
</div>
<div class="section" id="caching-tree-content-for-faster-lookup-operations">
<span id="cache-node-content"></span><h2><a class="toc-backref" href="#id24">Caching tree content for faster lookup operations</a><a class="headerlink" href="#caching-tree-content-for-faster-lookup-operations" title="Permalink to this headline">¶</a></h2>
<p>If your program needs to access to the content of different nodes very
frequently, traversing the tree to get the leaves of each node over
and over will produce significant slowdowns in your algorithm.  From
version 2.2 ETE provides a convenient methods to cache frequent data.</p>
<p>The method <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_cached_content" title="ete3.TreeNode.get_cached_content"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_cached_content()</span></code></a> returns a dictionary in
which keys are node instances and values represent the content of such
nodes. By default, content is understood as a list of leave nodes, so
looking up size or tip names under a given node will be
instant. However, specific attributes can be cached by setting a
custom <code class="xref py py-attr docutils literal"><span class="pre">store_attr</span></code> value.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

<span class="n">node2leaves</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>

<span class="c"># lets now print the size of each node without the need of</span>
<span class="c"># recursively traverse</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&quot;node </span><span class="si">%s</span><span class="s"> contains </span><span class="si">%s</span><span class="s"> tips&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node2leaves</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="section" id="node-annotation">
<h2><a class="toc-backref" href="#id25">Node annotation</a><a class="headerlink" href="#node-annotation" title="Permalink to this headline">¶</a></h2>
<p>Every node contains three basic attributes: name
(<code class="xref py py-attr docutils literal"><span class="pre">TreeNode.name</span></code>), branch length (<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.dist" title="ete3.TreeNode.dist"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></code></a>) and
branch support (<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.support" title="ete3.TreeNode.support"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.support</span></code></a>). These three values are
encoded in the newick format.  However, any extra data could be linked
to trees. This is called tree annotation.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.add_feature" title="ete3.TreeNode.add_feature"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.add_feature()</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.add_features" title="ete3.TreeNode.add_features"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.add_features()</span></code></a>
methods allow to add extra attributes (features) to any node.  The
first allows to add one one feature at a time, while the second can be
used to add many features with the same call.</p>
<p>Once extra features are added, you can access their values at any time
during the analysis of a tree. To do so, you only need to access to
the <code class="xref py py-attr docutils literal"><span class="pre">TreeNode.feature_name</span></code> attributes.</p>
<p>Similarly, <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.del_feature" title="ete3.TreeNode.del_feature"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.del_feature()</span></code></a> can be used to delete an
attribute.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Creates a tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span> <span class="s">&#39;((H:0.3,I:0.1):0.5, A:1, (B:0.4,(C:0.5,(J:1.3, (F:1.2, D:0.1):0.5):0.5):0.5):0.5);&#39;</span> <span class="p">)</span>

<span class="c"># Let&#39;s locate some nodes using the get common ancestor method</span>
<span class="n">ancestor</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># the search_nodes method (I take only the first match )</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># and using the shorcut to finding nodes by name</span>
<span class="n">C</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span>
<span class="n">H</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;H&quot;</span>
<span class="n">I</span><span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;I&quot;</span>

<span class="c"># Let&#39;s now add some custom features to our nodes. add_features can be</span>
<span class="c"># used to add many features at the same time.</span>
<span class="n">C</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">nodetype</span><span class="o">=</span><span class="s">&quot;internal&quot;</span><span class="p">)</span>

<span class="c"># Or, using the oneliner notation</span>
<span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;H&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c"># But we can automatize this. (note that i will overwrite the previous</span>
<span class="c"># values)</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
   <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s">&quot;AEIOU&quot;</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="c"># Now we use these information to analyze the tree.</span>
<span class="k">print</span> <span class="s">&quot;This tree has&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> <span class="s">&quot;vowel nodes&quot;</span>
<span class="k">print</span> <span class="s">&quot;Which are&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">vowel</span><span class="o">==</span><span class="bp">True</span><span class="p">]</span>

<span class="c"># But features may refer to any kind of data, not only simple</span>
<span class="c"># values. For example, we can calculate some values and store them</span>
<span class="c"># within nodes.</span>
<span class="c">#</span>
<span class="c"># Let&#39;s detect leaf nodes under &quot;ancestor&quot; with distance higher thatn</span>
<span class="c"># 1. Note that I&#39;m traversing a subtree which starts from &quot;ancestor&quot;</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="p">]</span>

<span class="c"># And save this pre-computed information into the ancestor node</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">&quot;long_branch_nodes&quot;</span><span class="p">,</span> <span class="n">matches</span><span class="p">)</span>

<span class="c"># Prints the precomputed nodes</span>
<span class="k">print</span> <span class="s">&quot;These are nodes under ancestor with long branches&quot;</span><span class="p">,</span> \
   <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">long_branch_nodes</span><span class="p">]</span>

<span class="c"># We can also use the add_feature() method to dynamically add new features.</span>
<span class="n">label</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;custom label:&quot;</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&quot;custom label value:&quot;</span><span class="p">)</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Ancestor has now the [&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="s">&quot;] attribute with value [&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">&quot;]&quot;</span>
</pre></div>
</div>
<p>Unfortunately, newick format does not support adding extra features to
a tree.  Because of this drawback, several improved formats haven been
(or are being) developed to read and write tree based
information. Some of these new formats are based in a completely new
standard (<a class="reference internal" href="tutorial_xml.html"><em>Phylogenetic XML standards</em></a>), while others are extensions of the
original newick format (NHX
<a class="reference external" href="http://phylosoft.org/NHX/http://phylosoft.org/NHX/">http://phylosoft.org/NHX/http://phylosoft.org/NHX/</a>).</p>
<p>Currently, ETE
includes support for the New Hampshire eXtended format (NHX), which
uses the original newick standard and adds the possibility of saving
additional date related to each tree node. Here is an example of a
extended newick representation in which extra information is added to
an internal node:</p>
<div class="highlight-python"><div class="highlight"><pre>(A:0.35,(B:0.72,(D:0.60,G:0.12):0.64[&amp;&amp;NHX:conf=0.01:name=INTERNAL]):0.56);
</pre></div>
</div>
<p>As you can notice, extra node features in the NHX format are enclosed
between brackets. ETE is able to read and write features using such
format, however, the encoded information is expected to be exportable
as plain text.</p>
<p>The NHX format is automatically detected when reading a newick file,
and the detected node features are added using the
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.add_feature" title="ete3.TreeNode.add_feature"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.add_feature()</span></code></a> method.  Consequently, you can access the
information by using the normal ETE&#8217;s feature notation:
<code class="docutils literal"><span class="pre">node.feature_name</span></code>. Similarly, features added to a tree can
be included within the normal newick representation using the NHX
notation. For this, you can call the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.write" title="ete3.TreeNode.write"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.write()</span></code></a> method
using the <code class="xref py py-attr docutils literal"><span class="pre">features</span></code> argument, which is expected to be a list
with the features names that you want to include in the newick
string. Note that all nodes containing the suplied features will be
exposed into the newick string. Use an empty features list
(<code class="xref py py-attr docutils literal"><span class="pre">features=[]</span></code>) to include all node&#8217;s data into the newick
string.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Creates a normal tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((H:0.3,I:0.1):0.5, A:1,(B:0.4,(C:0.5,(J:1.3,(F:1.2, D:0.1):0.5):0.5):0.5):0.5);&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c"># Let&#39;s locate some nodes using the get common ancestor method</span>
<span class="n">ancestor</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Let&#39;s label leaf nodes</span>
<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="s">&quot;AEIOU&quot;</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">leaf</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">vowel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="c"># Let&#39;s detect leaf nodes under &quot;ancestor&quot; with distance higher thatn</span>
<span class="c"># 1. Note that I&#39;m traversing a subtree which starts from &quot;ancestor&quot;</span>
<span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">dist</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="p">]</span>

<span class="c"># And save this pre-computed information into the ancestor node</span>
<span class="n">ancestor</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="s">&quot;long_branch_nodes&quot;</span><span class="p">,</span> <span class="n">matches</span><span class="p">)</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;NHX notation including vowel and confidence attributes&quot;</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;vowel&quot;</span><span class="p">,</span> <span class="s">&quot;confidence&quot;</span><span class="p">])</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;NHX notation including all node&#39;s data&quot;</span>
<span class="k">print</span>

<span class="c"># Note that when all features are requested, only those with values</span>
<span class="c"># equal to text-strings or numbers are considered. &quot;long_branch_nodes&quot;</span>
<span class="c"># is not included into the newick string.</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[])</span>
<span class="k">print</span>
<span class="k">print</span> <span class="s">&quot;basic newick formats are still available&quot;</span>
<span class="k">print</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;vowel&quot;</span><span class="p">])</span>
<span class="c"># You don&#39;t need to do anything speciall to read NHX notation. Just</span>
<span class="c"># specify the newick format and the NHX tags will be automatically</span>
<span class="c"># detected.</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">(((ADH2:0.1[&amp;&amp;NHX:S=human:E=1.1.1.1], ADH1:0.11[&amp;&amp;NHX:S=human:E=1.1.1.1])</span>
<span class="s">:0.05[&amp;&amp;NHX:S=Primates:E=1.1.1.1:D=Y:B=100], ADHY:0.1[&amp;&amp;NHX:S=nematode:</span>
<span class="s">E=1.1.1.1],ADHX:0.12[&amp;&amp;NHX:S=insect:E=1.1.1.1]):0.1[&amp;&amp;NHX:S=Metazoa:</span>
<span class="s">E=1.1.1.1:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH3:0.13[&amp;&amp;NHX:S=yeast:</span>
<span class="s">E=1.1.1.1], ADH2:0.12[&amp;&amp;NHX:S=yeast:E=1.1.1.1],ADH1:0.11[&amp;&amp;NHX:S=yeast:E=1.1.1.1]):0.1</span>
<span class="s">[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:E=1.1.1.1:D=N];</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="c"># Loads the NHX example found at http://www.phylosoft.org/NHX/</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
<span class="c"># And access node&#39;s attributes.</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s">&quot;S&quot;</span><span class="p">):</span>
       <span class="k">print</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">S</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-trees">
<span id="robinson-foulds"></span><span id="sec-modifying-tree-topology"></span><h2><a class="toc-backref" href="#id26">Comparing Trees</a><a class="headerlink" href="#comparing-trees" title="Permalink to this headline">¶</a></h2>
<div class="section" id="calculate-distances-between-trees">
<h3><a class="toc-backref" href="#id27">Calculate distances between trees</a><a class="headerlink" href="#calculate-distances-between-trees" title="Permalink to this headline">¶</a></h3>
<p>The <a href="#id1"><span class="problematic" id="id2">:Tree:`compare`</span></a> function allows to calculate distances between two trees
based on any node feature (i.e. name, species, other tags) using robinson-foulds
and edge compatibility distances. It automatically handles differences in tree
sizes, shared nodes and duplicated feature names.</p>
<ul class="simple">
<li>result[&#8220;rf&#8221;] = robinson-foulds distance between the two trees. (average of
robinson-foulds distances if target tree contained duplication and was split
in several subtrees)</li>
<li>result[&#8220;max_rf&#8221;] = Maximum robinson-foulds distance expected for this comparison</li>
<li>result[&#8220;norm_rf&#8221;] = normalized robinson-foulds distance (from 0 to 1)</li>
<li>result[&#8220;effective_tree_size&#8221;] = the size of the compared trees, which are pruned to the common shared nodes.</li>
<li>result[&#8220;ref_edges_in_source&#8221;] = compatibility score of the target tree with
respect to the source tree (how many edges in reference are found in the
source)</li>
<li>result[&#8220;source_edges_in_ref&#8221;] = compatibility score of the source tree with
respect to the reference tree (how many edges in source are found in the
reference)</li>
<li>result[&#8220;source_subtrees&#8221;] = number of subtrees in the source tree (1 if do not contain duplications)</li>
<li>result[&#8220;common_edges&#8221;] = a set of common edges between source tree and reference</li>
<li>result[&#8220;source_edges&#8221;] = the set of edges found in the source tree</li>
<li>result[&#8220;ref_edges&#8221;] = the set of edges found in the reference tree</li>
<li>result[&#8220;treeko_dist&#8221;] = TreeKO speciation distance for comparisons including duplication nodes.</li>
</ul>
</div>
<div class="section" id="robinson-foulds-distance">
<h3><a class="toc-backref" href="#id28">Robinson-foulds distance</a><a class="headerlink" href="#robinson-foulds-distance" title="Permalink to this headline">¶</a></h3>
<p>Two tree topologies can be compared using ETE and the Robinson-Foulds
(RF) metric. The method <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.robinson_foulds" title="ete3.TreeNode.robinson_foulds"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.robinson_foulds()</span></code></a> available for
any ETE tree node allows to:</p>
<blockquote>
<div><ul class="simple">
<li>compare two tree topologies by their name labels (default) or any
other annotated feature in the tree.</li>
<li>compare topologies of different size and content. When two trees
contain a different set of labels, only shared leaves will be used.</li>
<li>examine size and content of matching and missing partitions. Since
the method return the list of partitions found in both trees,
details about matching partitions can be obtained easily.</li>
</ul>
</div></blockquote>
<p>In the following example, several of above mentioned features are
shown:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((a,b),c), ((e, f), g));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((a,c),b), ((e, f), g));&#39;</span><span class="p">)</span>
<span class="n">rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">,</span> <span class="n">common_leaves</span><span class="p">,</span> <span class="n">parts_t1</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span>
<span class="k">print</span> <span class="s">&quot;RF distance is </span><span class="si">%s</span><span class="s"> over a total of </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Partitions in tree2 that were not found in tree1:&quot;</span><span class="p">,</span> <span class="n">parts_t1</span> <span class="o">-</span> <span class="n">parts_t2</span>
<span class="k">print</span> <span class="s">&quot;Partitions in tree1 that were not found in tree2:&quot;</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">-</span> <span class="n">parts_t1</span>

<span class="c"># We can also compare trees sharing only part of their labels</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((a,b),c), ((e, f), g));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((a,c),b), (g, H));&#39;</span><span class="p">)</span>
<span class="n">rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">,</span> <span class="n">common_leaves</span><span class="p">,</span> <span class="n">parts_t1</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="k">print</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span>
<span class="k">print</span> <span class="s">&quot;Same distance holds even for partially overlapping trees&quot;</span>
<span class="k">print</span> <span class="s">&quot;RF distance is </span><span class="si">%s</span><span class="s"> over a total of </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Partitions in tree2 that were not found in tree1:&quot;</span><span class="p">,</span> <span class="n">parts_t1</span> <span class="o">-</span> <span class="n">parts_t2</span>
<span class="k">print</span> <span class="s">&quot;Partitions in tree1 that were not found in tree2:&quot;</span><span class="p">,</span> <span class="n">parts_t2</span> <span class="o">-</span> <span class="n">parts_t1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modifying-tree-topology">
<h2><a class="toc-backref" href="#id29">Modifying Tree Topology</a><a class="headerlink" href="#modifying-tree-topology" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creating-trees-from-scratch">
<h3><a class="toc-backref" href="#id30">Creating Trees from Scratch</a><a class="headerlink" href="#creating-trees-from-scratch" title="Permalink to this headline">¶</a></h3>
<p>If no arguments are passed to the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode" title="ete3.TreeNode"><code class="xref py py-class docutils literal"><span class="pre">TreeNode</span></code></a> class constructor,
an empty tree node will be returned. Such an orphan node can be used
to populate a tree from scratch. For this, the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.up" title="ete3.TreeNode.up"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.up</span></code></a>,
and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.children" title="ete3.TreeNode.children"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.children</span></code></a> attributes should never be used (unless
it is strictly necessary). Instead, several methods exist to
manipulate the topology of a tree:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span> <span class="c"># Creates an empty tree</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="c"># Adds a new child to the current tree root</span>
                           <span class="c"># and returns it</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;B&quot;</span><span class="p">)</span> <span class="c"># Adds a second child to the current tree</span>
                           <span class="c"># root and returns it</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)</span> <span class="c"># Adds a new child to one of the branches</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">add_sister</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">)</span> <span class="c"># Adds a second child to same branch as</span>
                             <span class="c"># before, but using a sister as the starting</span>
                             <span class="c"># point</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;R&quot;</span><span class="p">)</span> <span class="c"># Adds a third child to the</span>
                           <span class="c"># branch. Multifurcations are supported</span>
<span class="c"># Next, I add 6 random leaves to the R branch names_library is an</span>
<span class="c"># optional argument. If no names are provided, they will be generated</span>
<span class="c"># randomly.</span>
<span class="n">R</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">names_library</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;r1&quot;</span><span class="p">,</span><span class="s">&quot;r2&quot;</span><span class="p">,</span><span class="s">&quot;r3&quot;</span><span class="p">,</span><span class="s">&quot;r4&quot;</span><span class="p">,</span><span class="s">&quot;r5&quot;</span><span class="p">,</span><span class="s">&quot;r6&quot;</span><span class="p">])</span>
<span class="c"># Prints the tree topology</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                     /-C</span>
<span class="c">#                    |</span>
<span class="c">#                    |--D</span>
<span class="c">#                    |</span>
<span class="c">#           /--------|                              /-r4</span>
<span class="c">#          |         |                    /--------|</span>
<span class="c">#          |         |          /--------|          \-r3</span>
<span class="c">#          |         |         |         |</span>
<span class="c">#          |         |         |          \-r5</span>
<span class="c">#          |          \--------|</span>
<span class="c"># ---------|                   |                    /-r6</span>
<span class="c">#          |                   |          /--------|</span>
<span class="c">#          |                    \--------|          \-r2</span>
<span class="c">#          |                             |</span>
<span class="c">#          |                              \-r1</span>
<span class="c">#          |</span>
<span class="c">#           \-B</span>
<span class="c"># a common use of the populate method is to quickly create example</span>
<span class="c"># trees from scratch. Here we create a random tree with 100 leaves.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="deleting-eliminating-and-removing-detaching-nodes">
<h3><a class="toc-backref" href="#id31">Deleting (eliminating) and Removing (detaching) nodes</a><a class="headerlink" href="#deleting-eliminating-and-removing-detaching-nodes" title="Permalink to this headline">¶</a></h3>
<p>As currently implemented, there is a difference between detaching and
deleting a node. The former disconnects a complete partition from the
tree structure, so all its descendants are also disconnected from the
tree. There are two methods to perform this action:
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.remove_child" title="ete3.TreeNode.remove_child"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.remove_child()</span></code></a> and <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.detach" title="ete3.TreeNode.detach"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.detach()</span></code></a>. In
contrast, deleting a node means eliminating such node without
affecting its descendants. Children from the deleted node are
automatically connected to the next possible parent. This is better
understood with the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Loads a tree. Note that we use format 1 to read internal node names</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K)D,(F,I)G)B,E)A,((L,(N,Q)O)J,(P,S)M)C);&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;original tree looks like this:&quot;</span>
<span class="c"># This is an alternative way of using &quot;print t&quot;. Thus we have a bit</span>
<span class="c"># more of control on how tree is printed. Here i print the tree</span>
<span class="c"># showing internal node names</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /A-------|          \G-------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-E</span>
<span class="c">#-NoName--|</span>
<span class="c">#         |                    /-L</span>
<span class="c">#         |          /J-------|</span>
<span class="c">#         |         |         |          /-N</span>
<span class="c">#         |         |          \O-------|</span>
<span class="c">#          \C-------|                    \-Q</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-P</span>
<span class="c">#                    \M-------|</span>
<span class="c">#                              \-S</span>
<span class="c"># Get pointers to specific nodes</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;G&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;J&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># If we remove J from the tree, the whole partition under J node will</span>
<span class="c"># be detached from the tree and it will be considered an independent</span>
<span class="c"># tree. We can do the same thing using two approaches: J.detach() or</span>
<span class="c"># C.remove_child(J)</span>
<span class="n">removed_node</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="c"># = C.remove_child(J)</span>
<span class="c"># if we know print the original tree, we will see how J partition is</span>
<span class="c"># no longer there.</span>
<span class="k">print</span> <span class="s">&quot;Tree after REMOVING the node J&quot;</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /A-------|          \G-------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#-NoName--|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-P</span>
<span class="c">#          \C------- /M-------|</span>
<span class="c">#                              \-S</span>
<span class="c"># however, if we DELETE the node G, only G will be eliminated from the</span>
<span class="c"># tree, and all its descendants will then hang from the next upper</span>
<span class="c"># node.</span>
<span class="n">G</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;Tree after DELETING the node G&quot;</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /D-------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /B-------|</span>
<span class="c">#                   |         |--F</span>
<span class="c">#          /A-------|         |</span>
<span class="c">#         |         |          \-I</span>
<span class="c">#         |         |</span>
<span class="c">#-NoName--|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-P</span>
<span class="c">#          \C------- /M-------|</span>
<span class="c">#                              \-S</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pruning-trees">
<h2><a class="toc-backref" href="#id32">Pruning trees</a><a class="headerlink" href="#pruning-trees" title="Permalink to this headline">¶</a></h2>
<p>Pruning a tree means to obtain the topology that connects a certain
group of items by removing the unnecessary edges. To facilitate this
task, ETE implements the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.prune" title="ete3.TreeNode.prune"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.prune()</span></code></a> method, which can be
used by providing the list of terminal and/or internal nodes that must
be kept in the tree.</p>
<p>From version 2.2, this function includes also the
<cite>preserve_branch_length</cite> flag, which allows to remove nodes from a
tree while keeping original distances among remaining nodes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Let&#39;s create simple tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((((H,K),(F,I)G),E),((L,(N,Q)O),(P,S)));&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Original tree looks like this:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                                        /-H</span>
<span class="c">#                              /--------|</span>
<span class="c">#                             |          \-K</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |         |          /-F</span>
<span class="c">#          /--------|          \--------|</span>
<span class="c">#         |         |                    \-I</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-E</span>
<span class="c">#---------|</span>
<span class="c">#         |                    /-L</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-N</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                    \-Q</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-P</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-S</span>
<span class="c"># Prune the tree in order to keep only some leaf nodes.</span>
<span class="n">t</span><span class="o">.</span><span class="n">prune</span><span class="p">([</span><span class="s">&quot;H&quot;</span><span class="p">,</span><span class="s">&quot;F&quot;</span><span class="p">,</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="s">&quot;Q&quot;</span><span class="p">,</span> <span class="s">&quot;P&quot;</span><span class="p">])</span>
<span class="k">print</span> <span class="s">&quot;Pruned tree&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                              /-F</span>
<span class="c">#                    /--------|</span>
<span class="c">#          /--------|          \-H</span>
<span class="c">#         |         |</span>
<span class="c">#---------|          \-E</span>
<span class="c">#         |</span>
<span class="c">#         |          /-Q</span>
<span class="c">#          \--------|</span>
<span class="c">#                    \-P</span>
<span class="c"># Let&#39;s re-create the same tree again</span>
</pre></div>
</div>
</div>
<div class="section" id="concatenating-trees">
<h2><a class="toc-backref" href="#id33">Concatenating trees</a><a class="headerlink" href="#concatenating-trees" title="Permalink to this headline">¶</a></h2>
<p>Given that all tree nodes share the same basic properties, they can be
connected freely. In fact, any node can add a whole subtree as a
child, so we can actually <em>cut &amp; paste</em> partitions. To do so, you only
need to call the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.add_child" title="ete3.TreeNode.add_child"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.add_child()</span></code></a> method using another tree
node as a first argument. If such a node is the root node of a
different tree, you will concatenate two structures. But caution!!,
this kind of operations may result into circular tree structures if
add an node&#8217;s ancestor as a new node&#8217;s child. Some basic checks are
internally performed by the ETE topology related methods, however, a
fully qualified check of this issue would affect seriously the
performance of the method. For this reason, users themselves should
take care about not creating circular structures by mistake.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Loads 3 independent trees</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(A,(B,C));&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;((D,E), (F,G));&#39;</span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(H, ((I,J), (K,L)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree1:&quot;</span><span class="p">,</span> <span class="n">t1</span>
<span class="c">#            /-A</span>
<span class="c">#  ---------|</span>
<span class="c">#           |          /-B</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-C</span>
<span class="k">print</span> <span class="s">&quot;Tree2:&quot;</span><span class="p">,</span> <span class="n">t2</span>
<span class="c">#                      /-D</span>
<span class="c">#            /--------|</span>
<span class="c">#           |          \-E</span>
<span class="c">#  ---------|</span>
<span class="c">#           |          /-F</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-G</span>
<span class="k">print</span> <span class="s">&quot;Tree3:&quot;</span><span class="p">,</span> <span class="n">t3</span>
<span class="c">#            /-H</span>
<span class="c">#           |</span>
<span class="c">#  ---------|                    /-I</span>
<span class="c">#           |          /--------|</span>
<span class="c">#           |         |          \-J</span>
<span class="c">#            \--------|</span>
<span class="c">#                     |          /-K</span>
<span class="c">#                      \--------|</span>
<span class="c">#                                \-L</span>
<span class="c"># Locates a terminal node in the first tree</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># and adds the two other trees as children.</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Resulting concatenated tree:&quot;</span><span class="p">,</span> <span class="n">t1</span>
<span class="c">#                                          /-D</span>
<span class="c">#                                /--------|</span>
<span class="c">#                               |          \-E</span>
<span class="c">#                      /--------|</span>
<span class="c">#                     |         |          /-F</span>
<span class="c">#                     |          \--------|</span>
<span class="c">#            /--------|                    \-G</span>
<span class="c">#           |         |</span>
<span class="c">#           |         |          /-H</span>
<span class="c">#           |         |         |</span>
<span class="c">#           |          \--------|                    /-I</span>
<span class="c">#           |                   |          /--------|</span>
<span class="c">#  ---------|                   |         |          \-J</span>
<span class="c">#           |                    \--------|</span>
<span class="c">#           |                             |          /-K</span>
<span class="c">#           |                              \--------|</span>
<span class="c">#           |                                        \-L</span>
<span class="c">#           |</span>
<span class="c">#           |          /-B</span>
<span class="c">#            \--------|</span>
<span class="c">#                      \-C</span>
</pre></div>
</div>
</div>
<div class="section" id="copying-duplicating-trees">
<span id="copying-trees"></span><span id="sec-tree-rooting"></span><h2><a class="toc-backref" href="#id34">Copying (duplicating) trees</a><a class="headerlink" href="#copying-duplicating-trees" title="Permalink to this headline">¶</a></h2>
<p>ETE provides several strategies to clone tree structures. The method
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.copy" title="ete3.TreeNode.copy"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.copy()</span></code></a> can be used to produce a new independent tree
object with the exact topology and features as the original. However,
as trees may involve many intricate levels of branches and nested
features, 4 different methods are available to create a tree copy:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;newick&#8221;: Tree topology, node names, branch lengths and branch
support values will be copied as represented in the newick string
This method is based on newick format serialization works very fast
even for large trees.</li>
<li>&#8220;newick-extended&#8221;: Tree topology and all node features will be
copied based on the extended newick format representation. Only
node features will be copied, thus excluding other node
attributes. As this method is also based on newick serialisation,
features will be converted into text strings when making the
copy. Performance will depend on the tree size and the number and
type of features being copied.</li>
<li>&#8220;cpickle&#8221;: This is the default method. The whole node structure and
its content will be cloned based on the cPickle object
serialization python approach.  This method is slower, but
recommended for full tree copying.</li>
<li>&#8220;deepcopy&#8221;: The whole node structure and its content is copied
based on the standard &#8220;copy&#8221; Python functionality. This is the
slowest method, but it allows to copy very complex objects even
when attributes point to lambda functions.</li>
</ul>
</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;((A, B)Internal_1:0.7, (C, D)Internal_2:0.5)root:1.3;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># we add a custom annotation to the node named A</span>
<span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;custom Value&quot;</span><span class="p">)</span>
<span class="c"># we add a complex feature to the A node, consisting of a list of lists</span>
<span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;dist&quot;</span><span class="p">,</span> <span class="s">&quot;label&quot;</span><span class="p">,</span> <span class="s">&quot;complex&quot;</span><span class="p">])</span>

<span class="c">#                         /-A, 0.0, custom Value, [[0, 1], [2, 3], [1, 11], [1, 0]]</span>
<span class="c">#          /Internal_1, 0.7</span>
<span class="c">#         |               \-B, 0.0</span>
<span class="c"># -root, 1.3</span>
<span class="c">#         |               /-C, 0.0</span>
<span class="c">#          \Internal_2, 0.5</span>
<span class="c">#                         \-D, 0.0</span>

<span class="c"># Newick copy will loose custom node annotations, complex features,</span>
<span class="c"># but not names and branch values</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;newick&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;dist&quot;</span><span class="p">,</span> <span class="s">&quot;label&quot;</span><span class="p">,</span> <span class="s">&quot;complex&quot;</span><span class="p">])</span>

<span class="c">#                           /-A, 0.0</span>
<span class="c">#            /Internal_1, 0.7</span>
<span class="c">#           |               \-B, 0.0</span>
<span class="c"># -NoName, 0.0</span>
<span class="c">#           |               /-C, 0.0</span>
<span class="c">#            \Internal_2, 0.5</span>
<span class="c">#                           \-D, 0.0</span>

<span class="c"># Extended newick copy will transfer custom annotations as text</span>
<span class="c"># strings, so complex features are lost.</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;newick-extended&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;dist&quot;</span><span class="p">,</span> <span class="s">&quot;label&quot;</span><span class="p">,</span> <span class="s">&quot;complex&quot;</span><span class="p">])</span>

<span class="c">#                              /-A, 0.0, custom Value, __0_ 1__ _2_ 3__ _1_ 11__ _1_ 0__</span>
<span class="c">#            /Internal_1, 0.7</span>
<span class="c">#           |               \-B, 0.0</span>
<span class="c"># -NoName, 0.0</span>
<span class="c">#           |               /-C, 0.0</span>
<span class="c">#            \Internal_2, 0.5</span>
<span class="c">#                           \-D, 0.0</span>

<span class="c"># The default pickle method will produce a exact clone of the</span>
<span class="c"># original tree, where features are duplicated keeping their</span>
<span class="c"># python data type.</span>

<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">attributes</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;dist&quot;</span><span class="p">,</span> <span class="s">&quot;label&quot;</span><span class="p">,</span> <span class="s">&quot;complex&quot;</span><span class="p">])</span>
<span class="k">print</span> <span class="s">&quot;first element in complex feature:&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="s">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">complex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#                         /-A, 0.0, custom Value, [[0, 1], [2, 3], [1, 11], [1, 0]]</span>
<span class="c">#          /Internal_1, 0.7</span>
<span class="c">#         |               \-B, 0.0</span>
<span class="c"># -root, 1.3</span>
<span class="c">#         |               /-C, 0.0</span>
<span class="c">#          \Internal_2, 0.5</span>
<span class="c">#                         \-D, 0.0</span>
<span class="c"># first element in complex feature: [0, 1]</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-multifurcations">
<span id="resolve-polytomy"></span><h2><a class="toc-backref" href="#id35">Solving multifurcations</a><a class="headerlink" href="#solving-multifurcations" title="Permalink to this headline">¶</a></h2>
<p>When a tree contains a polytomy (a node with more than 2 children),
the method <code class="xref py py-func docutils literal"><span class="pre">resolve_polytomy()</span></code> can be used to convert the node
into a randomly bifurcated structure in which branch lengths are set
to 0. This is really not a solution for the polytomy but it allows to
export the tree as a strictly bifurcated newick structure, which is a
requirement for some external software.</p>
<p>The method can be used on a very specific node while keeping the rest
of the tree intact by disabling the <code class="xref py py-attr docutils literal"><span class="pre">recursive</span></code> flag.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(( (a, b, c), (d, e, f, g)), (f, i, h));&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>

<span class="c">#             /-a</span>
<span class="c">#            |</span>
<span class="c">#         /--|--b</span>
<span class="c">#        |   |</span>
<span class="c">#        |    \-c</span>
<span class="c">#     /--|</span>
<span class="c">#    |   |    /-d</span>
<span class="c">#    |   |   | y</span>
<span class="c">#    |   |   |--e</span>
<span class="c">#    |    \--|</span>
<span class="c"># ---|       |--f</span>
<span class="c">#    |       |</span>
<span class="c">#    |        \-g</span>
<span class="c">#    |</span>
<span class="c">#    |    /-f</span>
<span class="c">#    |   |</span>
<span class="c">#     \--|--i</span>
<span class="c">#        |</span>
<span class="c">#         \-h</span>


<span class="n">polynode</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="n">polynode</span><span class="o">.</span><span class="n">resolve_polytomy</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>

<span class="c">#                 /-b</span>
<span class="c">#             /--|</span>
<span class="c">#         /--|    \-c</span>
<span class="c">#        |   |</span>
<span class="c">#        |    \-a</span>
<span class="c">#     /--|</span>
<span class="c">#    |   |    /-d</span>
<span class="c">#    |   |   |</span>
<span class="c">#    |   |   |--e</span>
<span class="c">#    |    \--|</span>
<span class="c"># ---|       |--f</span>
<span class="c">#    |       |</span>
<span class="c">#    |        \-g</span>
<span class="c">#    |</span>
<span class="c">#    |    /-f</span>
<span class="c">#    |   |</span>
<span class="c">#     \--|--i</span>
<span class="c">#        |</span>
<span class="c">#         \-h</span>


<span class="n">t</span><span class="o">.</span><span class="n">resolve_polytomy</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>

<span class="c">#</span>
<span class="c">#                 /-b</span>
<span class="c">#             /--|</span>
<span class="c">#         /--|    \-c</span>
<span class="c">#        |   |</span>
<span class="c">#        |    \-a</span>
<span class="c">#        |</span>
<span class="c">#     /--|            /-f</span>
<span class="c">#    |   |        /--|</span>
<span class="c">#    |   |    /--|    \-g</span>
<span class="c">#    |   |   |   |</span>
<span class="c">#    |    \--|    \-e</span>
<span class="c"># ---|       |</span>
<span class="c">#    |        \-d</span>
<span class="c">#    |</span>
<span class="c">#    |        /-i</span>
<span class="c">#    |    /--|</span>
<span class="c">#     \--|    \-h</span>
<span class="c">#        |</span>
<span class="c">#         \-f</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-rooting">
<h2><a class="toc-backref" href="#id36">Tree Rooting</a><a class="headerlink" href="#tree-rooting" title="Permalink to this headline">¶</a></h2>
<p>Tree rooting is understood as the technique by with a given tree is
conceptually polarized from more basal to more terminal nodes. In
phylogenetics, for instance, this a crucial step prior to the
interpretation of trees, since it will determine the evolutionary
relationships among the species involved. The concept of rooted trees
is different than just having a root node, which is always necessary
to handle a tree data structure. Usually, the way in which a tree is
differentiated between rooted and unrooted, is by counting the number
of branches of the current root node. Thus, if the root node has more
than two child branches, the tree is considered unrooted. By contrast,
when only two main branches exist under the root node, the tree is
considered rooted.</p>
<p>Having an unrooted tree means that any internal branch within the tree
could be regarded as the root node, and there is no conceptual reason
to place the root node where it is placed at the moment. Therefore, in
an unrooted tree, there is no information about which internal nodes
are more basal than others. By setting the root node between a given
edge/branch of the tree structure the tree is polarized, meaning that
the two branches under the root node are the most basal nodes. In
practice, this is usually done by setting an <strong>outgroup</strong> <strong>node</strong>,
which would represent one of these main root branches. The second one
will be, obviously, the brother node. When you set an outgroup on
unrooted trees, the multifurcations at the current root node are
solved.</p>
<p>In order to root an unrooted tree or re-root a tree structure, ETE
implements the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.set_outgroup" title="ete3.TreeNode.set_outgroup"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.set_outgroup()</span></code></a> method, which is present
in any tree node instance.  Similarly, the <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.unroot" title="ete3.TreeNode.unroot"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.unroot()</span></code></a>
method can be used to perform the opposite action.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># Load an unrooted tree. Note that three branches hang from the root</span>
<span class="c"># node. This usually means that no information is available about</span>
<span class="c"># which of nodes is more basal.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(A,(H,F),(B,(E,D)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Unrooted tree&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#          /-A</span>
<span class="c">#         |</span>
<span class="c">#         |          /-H</span>
<span class="c">#---------|---------|</span>
<span class="c">#         |          \-F</span>
<span class="c">#         |</span>
<span class="c">#         |          /-B</span>
<span class="c">#          \--------|</span>
<span class="c">#                   |          /-E</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>
<span class="c">#</span>
<span class="c"># Let&#39;s define that the ancestor of E and D as the tree outgroup.  Of</span>
<span class="c"># course, the definition of an outgroup will depend on user criteria.</span>
<span class="n">ancestor</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">ancestor</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree rooteda at E and D&#39;s ancestor is more basal that the others.&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                    /-B</span>
<span class="c">#          /--------|</span>
<span class="c">#         |         |          /-A</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-H</span>
<span class="c">#---------|                    \--------|</span>
<span class="c">#         |                              \-F</span>
<span class="c">#         |</span>
<span class="c">#         |          /-E</span>
<span class="c">#          \--------|</span>
<span class="c">#                    \-D</span>
<span class="c">#</span>
<span class="c"># Note that setting a different outgroup, a different interpretation</span>
<span class="c"># of the tree is possible</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;A&quot;</span> <span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree rooted at a terminal node&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-H</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |          \-F</span>
<span class="c">#          /--------|</span>
<span class="c">#         |         |          /-B</span>
<span class="c">#         |          \--------|</span>
<span class="c">#---------|                   |          /-E</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#         |                              \-D</span>
<span class="c">#         |</span>
<span class="c">#          \-A</span>
</pre></div>
</div>
<p>Note that although <strong>rooting</strong> is usually regarded as a whole-tree
operation, ETE allows to root subparts of the tree without affecting
to its parent tree structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(((A,C),((H,F),(L,M))),((B,(J,K)),(E,D)));&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Original tree:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-A</span>
<span class="c">#                    /--------|</span>
<span class="c">#                   |          \-C</span>
<span class="c">#                   |</span>
<span class="c">#          /--------|                    /-H</span>
<span class="c">#         |         |          /--------|</span>
<span class="c">#         |         |         |          \-F</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-L</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#---------|                              \-M</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-B</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-J</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                    \-K</span>
<span class="c">#                   |</span>
<span class="c">#                   |          /-E</span>
<span class="c">#                    \--------|</span>
<span class="c">#                              \-D</span>
<span class="c">#</span>
<span class="c"># Each main branch of the tree is independently rooted.</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;H&quot;</span><span class="p">)</span>
<span class="n">node2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">)</span>
<span class="n">node1</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s">&quot;H&quot;</span><span class="p">)</span>
<span class="n">node2</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Tree after rooting each node independently:&quot;</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#                              /-F</span>
<span class="c">#                             |</span>
<span class="c">#                    /--------|                    /-L</span>
<span class="c">#                   |         |          /--------|</span>
<span class="c">#                   |         |         |          \-M</span>
<span class="c">#                   |          \--------|</span>
<span class="c">#          /--------|                   |          /-A</span>
<span class="c">#         |         |                    \--------|</span>
<span class="c">#         |         |                              \-C</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-H</span>
<span class="c">#---------|</span>
<span class="c">#         |                    /-D</span>
<span class="c">#         |          /--------|</span>
<span class="c">#         |         |         |          /-B</span>
<span class="c">#         |         |          \--------|</span>
<span class="c">#          \--------|                   |          /-J</span>
<span class="c">#                   |                    \--------|</span>
<span class="c">#                   |                              \-K</span>
<span class="c">#                   |</span>
<span class="c">#                    \-E</span>
</pre></div>
</div>
</div>
<div class="section" id="working-with-branch-distances">
<h2><a class="toc-backref" href="#id37">Working with branch distances</a><a class="headerlink" href="#working-with-branch-distances" title="Permalink to this headline">¶</a></h2>
<p>The branch length between one node an its parent is encoded as the
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.dist" title="ete3.TreeNode.dist"><code class="xref py py-attr docutils literal"><span class="pre">TreeNode.dist</span></code></a> attribute. Together with tree topology, branch
lengths define the relationships among nodes.</p>
<div class="section" id="getting-distances-between-nodes">
<h3><a class="toc-backref" href="#id38">Getting distances between nodes</a><a class="headerlink" href="#getting-distances-between-nodes" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_distance" title="ete3.TreeNode.get_distance"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_distance()</span></code></a> method can be used to calculate the
distance between two connected nodes. There are two ways of using this
method: a) by querying the distance between two descendant nodes (two
nodes are passed as arguments) b) by querying the distance between the
current node and any other relative node (parental or descendant).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>

<span class="c"># Loads a tree with branch lenght information. Note that if no</span>
<span class="c"># distance info is provided in the newick, it will be initialized with</span>
<span class="c"># the default dist value = 1.0</span>
<span class="n">nw</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;(((A:0.1, B:0.01):0.001, C:0.0001):1.0,</span>
<span class="s">(((((D:0.00001,I:0):0,F:0):0,G:0):0,H:0):0,</span>
<span class="s">E:0.000001):0.0000001):2.0;&quot;&quot;&quot;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-A</span>
<span class="c">#                    /--------|</span>
<span class="c">#          /--------|          \-B</span>
<span class="c">#         |         |</span>
<span class="c">#         |          \-C</span>
<span class="c">#         |</span>
<span class="c">#         |                                                  /-D</span>
<span class="c">#         |                                        /--------|</span>
<span class="c">#---------|                              /--------|          \-I</span>
<span class="c">#         |                             |         |</span>
<span class="c">#         |                    /--------|          \-F</span>
<span class="c">#         |                   |         |</span>
<span class="c">#         |          /--------|          \-G</span>
<span class="c">#         |         |         |</span>
<span class="c">#          \--------|          \-H</span>
<span class="c">#                   |</span>
<span class="c">#                    \-E</span>
<span class="c">#</span>
<span class="c"># Locate some nodes</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;A&quot;</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;C&quot;</span>
<span class="c"># Calculate distance from current node</span>
<span class="k">print</span> <span class="s">&quot;The distance between A and C is&quot;</span><span class="p">,</span>  <span class="n">A</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Calculate distance between two descendants of current node</span>
<span class="k">print</span> <span class="s">&quot;The distance between A and C is&quot;</span><span class="p">,</span>  <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;C&quot;</span><span class="p">)</span>
<span class="c"># Calculate the toplogical distance (number of nodes in between)</span>
<span class="k">print</span> <span class="s">&quot;The number of nodes between A and D is &quot;</span><span class="p">,</span>  \
    <span class="n">t</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Additionally to this, ETE incorporates two more methods to calculate
the most distant node from a given point in a tree. You can use the
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_farthest_node" title="ete3.TreeNode.get_farthest_node"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_farthest_node()</span></code></a> method to retrieve the most distant
point from a node within the whole tree structure. Alternatively,
<a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_farthest_leaf" title="ete3.TreeNode.get_farthest_leaf"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_farthest_leaf()</span></code></a> will return the most distant
descendant (always a leaf). If more than one node matches the farthest
distance, the first occurrence is returned.</p>
<p>Distance between nodes can also be computed as the number of nodes
between them (considering all branch lengths equal to 1.0). To do so,
the <strong>topology_only</strong> argument must be set to <strong>True</strong> for all the
above mentioned methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Calculate the farthest node from E within the whole structure</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;E&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;The farthest node from E is&quot;</span><span class="p">,</span> <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with dist=&quot;</span><span class="p">,</span> <span class="n">dist</span>
<span class="c"># Calculate the farthest node from E within the whole structure,</span>
<span class="c"># regarding the number of nodes in between as distance value</span>
<span class="c"># Note that the result is differnt.</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="s">&quot;E&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">(</span><span class="n">topology_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;The farthest (topologically) node from E is&quot;</span><span class="p">,</span> \
    <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="s">&quot;nodes in between&quot;</span>
<span class="c"># Calculate farthest node from an internal node</span>
<span class="n">farthest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&quot;The farthest node from root is&quot;</span><span class="p">,</span> <span class="n">farthest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;with dist=&quot;</span><span class="p">,</span> <span class="n">dist</span>
<span class="c">#</span>
<span class="c"># The program results in the following information:</span>
<span class="c">#</span>
<span class="c"># The distance between A and C is 0.1011</span>
<span class="c"># The distance between A and C is 0.1011</span>
<span class="c"># The number of nodes between A and D is  8.0</span>
<span class="c"># The farthest node from E is A with dist= 1.1010011</span>
<span class="c"># The farthest (topologically) node from E is I with 5.0 nodes in between</span>
<span class="c"># The farthest node from root is A with dist= 1.101</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-midpoint-outgroup">
<span id="sub-getting-midpoint-outgroup"></span><h3><a class="toc-backref" href="#id39">getting midpoint outgroup</a><a class="headerlink" href="#getting-midpoint-outgroup" title="Permalink to this headline">¶</a></h3>
<p>In order to obtain a balanced rooting of the tree, you can set as the tree
outgroup that partition which splits the tree in two equally distant clusters
(using branch lengths). This is called the midpoint outgroup.</p>
<p>The <a class="reference internal" href="../reference/reference_tree.html#ete3.TreeNode.get_midpoint_outgroup" title="ete3.TreeNode.get_midpoint_outgroup"><code class="xref py py-func docutils literal"><span class="pre">TreeNode.get_midpoint_outgroup()</span></code></a> method will return the
outgroup partition that splits current node into two balanced branches
in terms of node distances.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ete3</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="c"># generates a random tree</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">();</span>
<span class="n">t</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#                    /-qogjl</span>
<span class="c">#          /--------|</span>
<span class="c">#         |          \-vxbgp</span>
<span class="c">#         |</span>
<span class="c">#         |          /-xyewk</span>
<span class="c">#---------|         |</span>
<span class="c">#         |         |                    /-opben</span>
<span class="c">#         |         |                   |</span>
<span class="c">#         |         |          /--------|                    /-xoryn</span>
<span class="c">#          \--------|         |         |          /--------|</span>
<span class="c">#                   |         |         |         |         |          /-wdima</span>
<span class="c">#                   |         |          \--------|          \--------|</span>
<span class="c">#                   |         |                   |                    \-qxovz</span>
<span class="c">#                   |         |                   |</span>
<span class="c">#                   |         |                    \-isngq</span>
<span class="c">#                    \--------|</span>
<span class="c">#                             |                    /-neqsc</span>
<span class="c">#                             |                   |</span>
<span class="c">#                             |                   |                              /-waxkv</span>
<span class="c">#                             |          /--------|                    /--------|</span>
<span class="c">#                             |         |         |          /--------|          \-djeoh</span>
<span class="c">#                             |         |         |         |         |</span>
<span class="c">#                             |         |          \--------|          \-exmsn</span>
<span class="c">#                              \--------|                   |</span>
<span class="c">#                                       |                   |          /-udspq</span>
<span class="c">#                                       |                    \--------|</span>
<span class="c">#                                       |                              \-buxpw</span>
<span class="c">#                                       |</span>
<span class="c">#                                        \-rkzwd</span>
<span class="c"># Calculate the midpoint node</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_midpoint_outgroup</span><span class="p">()</span>
<span class="c"># and set it as tree outgroup</span>
<span class="n">t</span><span class="o">.</span><span class="n">set_outgroup</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span>
<span class="c">#                              /-opben</span>
<span class="c">#                             |</span>
<span class="c">#                    /--------|                    /-xoryn</span>
<span class="c">#                   |         |          /--------|</span>
<span class="c">#                   |         |         |         |          /-wdima</span>
<span class="c">#                   |          \--------|          \--------|</span>
<span class="c">#          /--------|                   |                    \-qxovz</span>
<span class="c">#         |         |                   |</span>
<span class="c">#         |         |                    \-isngq</span>
<span class="c">#         |         |</span>
<span class="c">#         |         |          /-xyewk</span>
<span class="c">#         |          \--------|</span>
<span class="c">#         |                   |          /-qogjl</span>
<span class="c">#         |                    \--------|</span>
<span class="c">#---------|                              \-vxbgp</span>
<span class="c">#         |</span>
<span class="c">#         |                    /-neqsc</span>
<span class="c">#         |                   |</span>
<span class="c">#         |                   |                              /-waxkv</span>
<span class="c">#         |          /--------|                    /--------|</span>
<span class="c">#         |         |         |          /--------|          \-djeoh</span>
<span class="c">#         |         |         |         |         |</span>
<span class="c">#         |         |          \--------|          \-exmsn</span>
<span class="c">#          \--------|                   |</span>
<span class="c">#                   |                   |          /-udspq</span>
<span class="c">#                   |                    \--------|</span>
<span class="c">#                   |                              \-buxpw</span>
<span class="c">#                   |</span>
<span class="c">#                    \-rkzwd</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tutorial_drawing.html" class="btn btn-neutral float-right" title="The Programmable Tree Drawing Engine" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="The ETE tutorial" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, The ETE Toolkit Team.
      Last updated on Mar 18, 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.0.0b35',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>